from typing import Any, Dict, Optional
from s3fs.core import S3FileSystem
from kedro.io.core import AbstractDataSet, DataSetError, S3PathVersionMixIn, Version


class CSVtoS3DictDataSet(AbstractDataSet, S3PathVersionMixIn):
    """``CSVtoS3DictDataSet`` saves data to a file in S3. It uses s3fs
    to write to S3
    """

    def _describe(self) -> Dict[str, Any]:
        return dict(
            filepath=self._filepath,
            bucket_name=self._bucket_name,
            load_args=self._load_args,
            save_args=self._save_args,
            version=self._version,
            )

    def __init__(
            self,
            filepath: str,
            bucket_name: str,
            credentials: Optional[Dict[str, Any]] = None,
            load_args: Optional[Dict[str, Any]] = None,
            save_args: Optional[Dict[str, Any]] = None,
            version: Version = None,
    ) -> None:
        """Creates a new instance of ``CSVtoS3DictDataSet`` pointing to a concrete
        parquet file on S3.

        Args:
            filepath: Path to a parquet file.
            bucket_name: S3 bucket name.
            credentials: Credentials to access the S3 bucket, such as
                ``aws_access_key_id``, ``aws_secret_access_key``.
            load_args: ignored since loading is not supported
            save_args: multiFile: allows for multiple mp4 objects
                to be saved.
            version: If specified, should be an instance of
                ``kedro.io.core.Version``. If its ``load`` attribute is
                None, the latest version will be loaded. If its ``save``
                attribute is None, save version will be autogenerated.

        """
        default_save_args = {'multiFile': False}
        default_load_args = {}
        self._save_args = (
            {**default_save_args, **save_args} if save_args else default_save_args
        )
        self._load_args = (
            {**default_load_args, **load_args}
            if load_args is not None
            else default_load_args
        )
        self._filepath = filepath
        self._bucket_name = bucket_name
        self._credentials = credentials if credentials else {}
        self._version = version
        self._s3 = S3FileSystem(client_kwargs=self._credentials)

    @property
    def _client(self):
        return self._s3.s3

    def _load(self) -> str:
        raise DataSetError("Loading not supported for CSVtoS3DictDataSet")

    def _save(self, data: dict) -> None:

        for csv_dir, csv_file in data.items():

            save_key = self._get_save_path(
                self._client, self._bucket_name, self._filepath, csv_dir, self._version
            )

            with self._s3.open(
                    "{}/{}".format(self._bucket_name, save_key), mode="wb"
            ) as s3_file:
                # Only binary read and write modes are implemented for S3Files
                s3_file.write(csv_file.to_csv(**self._save_args).encode("utf8"))

    def _exists(self) -> bool:
        try:
            load_key = self._get_load_path(
                self._client, self._bucket_name, self._filepath, self._version
            )
        except DataSetError:
            return False
        args = (self._client, self._bucket_name, load_key)
        return any(key == load_key for key in self._list_objects(*args))

