from typing import Any, Dict, Optional
import pandas as pd
from s3fs.core import S3FileSystem
from kedro.io.core import AbstractDataSet, DataSetError, S3PathVersionMixIn, Version


class ParquetS3DataSet(AbstractDataSet, S3PathVersionMixIn):
    """``ParquetS3DataSet`` loads and saves data to a file in S3. It uses s3fs
    to read and write from S3 and pandas to handle parquet csv file.
    """

    def _describe(self) -> Dict[str, Any]:
        return dict(
            filepath=self._filepath,
            bucket_name=self._bucket_name,
            engine=self._engine,
            load_args=self._load_args,
            save_args=self._save_args,
            version=self._version,
            )

    def __init__(
            self,
            filepath: str,
            bucket_name: str,
            engine: str = "auto",
            credentials: Optional[Dict[str, Any]] = None,
            load_args: Optional[Dict[str, Any]] = None,
            save_args: Optional[Dict[str, Any]] = None,
            version: Version = None,
    ) -> None:
        """Creates a new instance of ``ParquetS3DataSet`` pointing to a concrete
        parquet file on S3.

        Args:
            filepath: Path to a parquet file.
            bucket_name: S3 bucket name.
            engine: The engine to use, one of: `auto`, `fastparquet`,
                `pyarrow`. If `auto`, then the default behavior is to try
                `pyarrow`, falling back to `fastparquet` if `pyarrow` is
                unavailable.
            credentials: Credentials to access the S3 bucket, such as
                ``aws_access_key_id``, ``aws_secret_access_key``.
            load_args: Additional loading options `pyarrow`:
                https://arrow.apache.org/docs/python/generated/pyarrow.parquet.read_table.html
                or `fastparquet`:
                https://fastparquet.readthedocs.io/en/latest/api.html#fastparquet.ParquetFile.to_pandas
            save_args: Additional saving options for `pyarrow`:
                https://arrow.apache.org/docs/python/generated/pyarrow.Table.html#pyarrow.Table.from_pandas
                or `fastparquet`:
                https://fastparquet.readthedocs.io/en/latest/api.html#fastparquet.write
            version: If specified, should be an instance of
                ``kedro.io.core.Version``. If its ``load`` attribute is
                None, the latest version will be loaded. If its ``save``
                attribute is None, save version will be autogenerated.

        """
        default_save_args = {"compression": None}
        default_load_args = {}
        self._save_args = (
            {**default_save_args, **save_args} if save_args else default_save_args
        )
        self._load_args = (
            {**default_load_args, **load_args}
            if load_args is not None
            else default_load_args
        )
        self._filepath = filepath
        self._engine = engine
        self._bucket_name = bucket_name
        self._credentials = credentials if credentials else {}
        self._version = version
        self._s3 = S3FileSystem(client_kwargs=self._credentials)

    @property
    def _client(self):
        return self._s3.s3

    def _load(self) -> pd.DataFrame:
        load_key = self._get_load_path(
            self._client, self._bucket_name, self._filepath, self._version
        )

        with self._s3.open(
                "{}/{}".format(self._bucket_name, load_key), mode="rb"
        ) as s3_file:
            return pd.read_parquet(s3_file, engine=self._engine, **self._load_args)

    def _save(self, data: pd.DataFrame) -> None:
        save_key = self._get_save_path(
            self._client, self._bucket_name, self._filepath, self._version
        )

        with self._s3.open(
                "{}/{}".format(self._bucket_name, save_key), mode="wb"
        ) as s3_file:
            # Only binary read and write modes are implemented for S3Files
            data.to_parquet(s3_file, engine=self._engine, **self._save_args)

        load_key = self._get_load_path(
            self._client, self._bucket_name, self._filepath, self._version
        )
        self._check_paths_consistency(load_key, save_key)

    def _exists(self) -> bool:
        try:
            load_key = self._get_load_path(
                self._client, self._bucket_name, self._filepath, self._version
            )
        except DataSetError:
            return False
        args = (self._client, self._bucket_name, load_key)
        return any(key == load_key for key in self._list_objects(*args))

